# Бэкенд для платежной системы p2p

## Настройки
Настройки для часовой зоны Мск.

    LANGUAGE_CODE = 'ru-RU'
    TIME_ZONE = 'Europe/Moscow'

## Кастомная модель пользователя

Устанавливается кастомная модель пользователя

*settings.py*

    AUTH_USER_MODEL = 'users.User'

*users: models.py*

    class User(AbstractUser):

## Шаблон

Исключительно для заглушки стартовой страницы установлен шаблон Bootstrap Carousel.

## Как установить (для локальной разработки)

1. Установить Python 3.10+. [см. как установить (англ.)](https://realpython.com/installing-python/), а [здесь для Debian-based (рус.)](http://userone.ru/?q=node/41).

2. Установить переменные окружения (см. ниже).
3. Установить виртуальное окружение:
```
    python3 -m venv env
    source env/bin/activate
```
4. Установить зависимости (для разработки requirements_dev.txt, для  requirements.txt):
```
    pip install -r requirements.txt
```
5. Создать базу данных.
```
su - postgres
psql
CREATE DATABASE p2p_db TEMPLATE=template0 ENCODING 'UTF8' LC_COLLATE 'C' LC_CTYPE 'C';
```
Создать пользователя, передав ему все права на эту БД.

6. Запустить миграции:
```
    ./manage.py migrate
```
7. Протестировать, что проект нормально запускается:
```
    ./manage.py runserver
```

## Переменные окружения

Для улучшения уровня безопасности, когда будешь размещать сайт в общем доступе, сделай файл *.env* и размести его в папке настроек проекта *project*. В этом файле укажи:

* секретный ключ Django;
* данные для подключения к БД
* DEBUG и ALLOWED_HOSTS
* настройки почтового сервера


Вот так должен выглядеть твой .env файл:

    SECRET_KEY='длинная строка символов'
    DEBUG=False
    ALLOWED_HOSTS=127.0.0.1,[::1]
    DB_URL=postgres://user_name:password@host:port/db_name


если используется рассылка email, то потребуются данные почтового сервера:

    EMAIL_HOST='<smtp-server>'
    EMAIL_PORT=<port>
    EMAIL_USE_SSL=True
    EMAIL_HOST_PASSWORD='<password>'
    EMAIL_HOST_USER='<login name>'
    DEFAULT_FROM_EMAIL='<from email>'

## Указания по разработке

### Роли участников проекта

- **заказчик** - тот для кого все делается и тот кто оплачивает работу
- **архитектор** - сотрудник определяющий архитектуру проекта, взаимодействие модулей
- **руководитель проекта** - сотрудник, отвечающий за разработку проекта 
- **разработчик** - сотрудник выполняющий написание кода
- **ревьювер** - сотрудник выполняющий код ревью
- **тестер** - сотрудник выполняющий тестирование

### Требования к коду проекта Python

- строгое соблюдение PEP8;
- `import this`;
- длина строки - 120 символов;
- грамотный английский для имен;
- не допускаются бессмысленные имена (за исключением переменной цикла, при условии что тело цикла не более 20 строк);
- именование моделей в обязательном порядке должно быть согласовано с **архитектором** или **руководителем проекта**;
- перед мержем в репозиторий из бранча должны быть вычищены все рабочие комментарии, старый код, отладочный код;
- перед мержем в мастер (dev, test, prod) все миграции по задаче должны быть объединены в одну - поэтому перед мержем мастера в свой бранч откатываем миграции бранча, удаляем их,накатываем миграции мастера после этого создаем свои миграции и накатываем их по-новой;
- все "инициализационные данные" должны быть в data-migrations;
- каждый модуль в обязательном порядке содержит `__all__`;
- если модуль содержит много (3 и более) моделей, вьювов и т.д., то оформляем модуль как пакет и разносим все по 
внутренним модулям;
- функция или метод не должны занимать более 40 строк;
- проект русскоязычный;
- `black` и другие автоформаттеры не использовать (только если явно и только для "своего" кода);
- миграция с данными всегда называется `NNNN_initial_data_<info>.py`, их не удаляем и не трогаем;
- миграции с данными лежат в отдельной папке `migrations/data`;
- все остальные миграции можно смело пересоздавать - по крайней мере до момента запуска MVP на стейдже;
- первый параметр __new__ - metacls;
- Django `update` используется только после утверждения **руководителем проекта** или **архитектором**;
- все локальные настройки делаются в файле project/local_settings.py;

## Требования к логированию
- все исключения и ошибки логируются в обязательном порядке

- лог должен сохранять ссылки на все объекты в виде `класс_объекта[идентификатор]`,  **класс_объекта** пишется
строчными буквами, например `logger.info('test for user[%i], company[%i]', user.id, company.id)`


## Требования к документированию
- код должен быть самодокументированным. то есть все имена должны корректно описывать именуемую сущность;
- весь функционал, который не является стандартным для используемых фрекймворков в обязательном порядке должен быть
снабжен исчерпывающими комментариями;
- все комментарии ведутся на русском языке;
- все методы api должны быть документированы в Swagger;
- каждый коммит должен быть снабжен ясным комментарием;


## Cтруктура приложения (django app)

    app
    |
    +--apps.py  
    |
    +--models (models.py)
    |  |
    |  + model_1  ( Model1 Model1Manager)
    |  | 
    |  + model_2  ( Model2 Model2Manager)
    | 
    +--views  (views.py)
    |  |
    |  ....
    |  
    +--tests  (test.py)
    |  |
    |  ....
    |
    +--services (services.py)
    |  |
    |  ....
    |   
    +--tasks (tasks.py)
    |  |
    |  ....
    |
    +--serializers (serializers.py)
    |  |
    |  ....
    |
    +--filters (filters.py)
    |  |
    |  ....
    |
    +--admin (admin.py)
    |  |
    |  ....
    |   
    +--management ....
    |   
    +--migrations ....
    |   
    +--constants.py   - неизменяемые (в процессе эксплуатации) константы модуля константы, 
                        изменяемые (в процессе эксплуатации) настройки хранятся в Constance)



## Требования тестам

- весь функционал в обязательном порядке должен быть покрыт авто-тестами;
- для каждой модели должны быть написаны тесты по ее созданию, удалению, изменению;
- для каждого сервиса должен быть написан тест;
- для каджого api метода должен быть написан тест;
- специально тестируется подсистема аутентификации и авторизации;

## Порядок разработки проекта

1. **Заказчик** совместно с **руководителем проекта** определяют необходимый функционал
2. **Руководитель проекта** формирует список задач и размещает их в таск-трекере (состояние *новое*)
3. Для выполнения задачи **разработчик** создает бранч в git (наследуя его от `dev`). Если выполнение задачи
завязано на предыдущую, но бранч еще не замержен в `dev` допускается наследовать от бранча предыдущей задачи.
В таск-трекере задача помечается статусом *в работе* 
4. Вся разработка задачи ведется в этом бранче. Разработчик ежедневно пушит рабочий бранч в репозиторий 
вне зависимости от его завершенности.
5. После завершения работ по задаче **разработчик** мержит dev в свой бранч, и после разрешения конфликтов
выполняет полный автотест;
6. После успешного прохождения автотеста **разработчик** пушит свой бранч в репозиторий и создает мерж-реквест 
в `dev`. В таск-трекере задача помечается статусом *ревью*
7. **Ревьювер** выполняет код ревью, **разработчик** правит обнаруженные замечания
8. После прохождения код ревью бранч мержится в `dev`. В таск трекере задача помечается статусом *тестирование*
9. **Тестер** выполняет автотесты, smoke test, и детальный тест реализованного функционала и при их успешном 
прохождении в таск-трекере задача помечается статусом *завершено*

## Важные замечания общего характера

- Добавление любого пакета должно быть в обязательном порядке согласовано с **архитектором**;
- Для добавления пакета он заносится (без версии - если это работает) в файл `requirements-base.txt`,
затем выполняется `pip install -r requirements-base.txt`

# Архитектура проекта

## Основные положения

- модель "тонкая", view "тонкий", вся бизнес-логика помещается в сервисах (модуль `services`);
- все длительные задачи выполняются в фоне (celery);
- для периодических задач используется celery_beat;
- взаимодействие между разными моделями выполняется через сигналы django;
- все настройки выносятся в Constance;
- для всех значимых моделей ведется история изменений (используем django-simple-history)

## Используемые фреймворки и библиотеки
- **Django 4** - ядро
- **Django Rest Framework** - основное api
- **Django Channels** - асинхронное взаимодействие с веб-клиентом
- **Django Channels Rest Framework** - отправка моделей веб-клиенту
- **Service objects for Django** - для создания сервисов
- **Celery** - для фоновых и периодических задач 
- **transitions** - для построения конечного автомата состояния турпакета, броней и т.д
- **markdown** - все текстовые описания в системе в формате `markdown`
- **drf-yasg** - для Swagger
- **Constance** - для настроек проекта
- **django-simple-history** - для сохранения истории
- **django-mptt** - для построения MPTT дерева 

## Авторизация 

При выполнении всех операций проверяется право доступа. Право доступа проверяется на уровне View-а 
средствами DRF. Реализуется проверка прав доступа на основе ролей пользователя и владения 
пользователем объектами с которыми будет выполняться операция.
Для этого должен быть написан универсальный декоратор `has_access_to(user, objects, access)`

Все классы объектов самостоятельно контролируют доступ к ним. Этого каждый объект участвующие в системе 
проверки прав наследуются от `PermissionsProto` и переопределяет метод `grant_access`

## RBAC

Разграничения доступа по ролям осуществляется на уровне модели целиком. Для каждой модели должны определяться 
права базовые доступа, которые должны проверяться при выполнении CRUD:
- `model_name__create`
- `model_name__update`
- `model_name__read`
- `model_name__delete`

## Доступ к полям модели

Поля моделей делятся на следующие классы
- **immutable** - неизменяемые - изменение данных полей невозможно 
- **privileged** - изменение данных полей возможно только через операции с моделями. Не должно быть возможности изменить данные поля через обычное присваивание. (Для сохранения `privileged` полей необходимо указывать параметр `save_privileged` в методе `save` либо явно выставлять флаг модели `save_privileged`)
- **mutable** - обычные поля, изменения которых возможно в общем порядке через метод save

Для задания классов полей модель должна содержать

    class Meta:
        privileged_fields = ('x', 'y')
        immutable_fields = ('w', 'z')

## APPs & models

- `users` - пользователи, роли
  * `User` - пользователь системы
